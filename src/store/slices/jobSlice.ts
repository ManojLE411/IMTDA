/**
 * Job Slice
 * Manages job positions state and operations
 */

import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { Job, JobApplication } from '@/types/job.types';
import { jobApi } from '@/services/jobApi';
import { isValidObjectId } from '@/utils/validation';

interface JobState {
  jobs: Job[];
  applications: JobApplication[];
  loading: boolean;
  applicationsLoading: boolean;
  error: string | null;
}

const initialState: JobState = {
  jobs: [],
  applications: [],
  loading: true,
  applicationsLoading: true,
  error: null,
};

/**
 * Load jobs from API
 */
export const loadJobs = createAsyncThunk('job/load', async () => {
  return jobApi.getAll();
});

/**
 * Save job
 */
export const saveJob = createAsyncThunk(
  'job/save',
  async (job: Job, { dispatch }) => {
    const { id, ...jobData } = job;
    const savedJob = id && isValidObjectId(id) ? await jobApi.update(id, jobData) : await jobApi.create(jobData);
    dispatch(loadJobs());
    return savedJob;
  }
);

/**
 * Delete job
 */
export const deleteJob = createAsyncThunk(
  'job/delete',
  async (id: string, { dispatch }) => {
    await jobApi.delete(id);
    dispatch(loadJobs());
    return id;
  }
);

/**
 * Load job applications from API
 */
export const loadJobApplications = createAsyncThunk(
  'job/loadApplications',
  async () => {
    return jobApi.getAllApplications();
  }
);

/**
 * Apply for job
 */
export const applyForJob = createAsyncThunk(
  'job/apply',
  async (payload: { application: JobApplication; resumeFile?: File }, { dispatch }) => {
    // Strip fields that should be generated by the API
    const { id, date, status, resumeName, resumePath, ...applicationData } = payload.application;
    const savedApplication = await jobApi.submitApplication(applicationData, payload.resumeFile);
    dispatch(loadJobApplications());
    return savedApplication;
  }
);

/**
 * Delete job application
 */
export const deleteJobApplication = createAsyncThunk(
  'job/deleteApplication',
  async (id: string, { dispatch }) => {
    await jobApi.deleteApplication(id);
    dispatch(loadJobApplications());
    return id;
  }
);

/**
 * Update job application status
 */
export const updateJobApplicationStatus = createAsyncThunk(
  'job/updateApplicationStatus',
  async ({ id, status }: { id: string; status: JobApplication['status'] }, { dispatch }) => {
    await jobApi.updateApplicationStatus(id, status);
    dispatch(loadJobApplications());
    return { id, status };
  }
);

const jobSlice = createSlice({
  name: 'job',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Load jobs
      .addCase(loadJobs.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loadJobs.fulfilled, (state, action) => {
        state.loading = false;
        // Ensure payload is an array and has id fields
        state.jobs = Array.isArray(action.payload) ? action.payload : [];
      })
      .addCase(loadJobs.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to load jobs';
        // Keep existing jobs on error instead of clearing
        if (state.jobs.length === 0) {
          state.jobs = [];
        }
      })
      // Load applications
      .addCase(loadJobApplications.pending, (state) => {
        state.applicationsLoading = true;
        state.error = null;
      })
      .addCase(loadJobApplications.fulfilled, (state, action) => {
        state.applicationsLoading = false;
        // Ensure payload is an array and has id fields
        state.applications = Array.isArray(action.payload) ? action.payload : [];
      })
      .addCase(loadJobApplications.rejected, (state, action) => {
        state.applicationsLoading = false;
        state.error = action.error.message || 'Failed to load applications';
        // Keep existing applications on error
        if (state.applications.length === 0) {
          state.applications = [];
        }
      })
      // Save/delete job
      .addCase(saveJob.fulfilled, (state) => {
        // Jobs are already updated via loadJobs
      })
      .addCase(saveJob.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to save job';
      })
      .addCase(deleteJob.fulfilled, (state) => {
        // Jobs are already updated via loadJobs
      })
      .addCase(deleteJob.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to delete job';
      })
      // Application
      .addCase(applyForJob.fulfilled, (state) => {
        // Applications are already updated via loadJobApplications
      })
      .addCase(applyForJob.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to submit application';
      })
      .addCase(deleteJobApplication.fulfilled, (state) => {
        // Applications are already updated via loadJobApplications
      })
      .addCase(deleteJobApplication.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to delete application';
      })
      .addCase(updateJobApplicationStatus.fulfilled, (state) => {
        // Applications are already updated via loadJobApplications
      })
      .addCase(updateJobApplicationStatus.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to update application status';
      });
  },
});

export const { clearError } = jobSlice.actions;

// Selectors
export const selectJobs = (state: { job: JobState }) => state.job?.jobs || [];
export const selectJobLoading = (state: { job: JobState }) =>
  state.job?.loading ?? true;
export const selectJobApplications = (state: { job: JobState }) =>
  state.job?.applications || [];
export const selectJobApplicationsLoading = (state: { job: JobState }) =>
  state.job?.applicationsLoading ?? true;
export const selectJobError = (state: { job: JobState }) => state.job?.error || null;

export default jobSlice.reducer;

