/**
 * Internship Slice
 * Manages internship tracks and applications state
 */

import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { InternshipTrack, InternshipApplication } from '@/types/internship.types';
import { internshipApi } from '@/services/internshipApi';
import { isValidObjectId } from '@/utils/validation';

interface InternshipState {
  tracks: InternshipTrack[];
  applications: InternshipApplication[];
  loading: boolean;
  applicationsLoading: boolean;
  error: string | null;
}

const initialState: InternshipState = {
  tracks: [],
  applications: [],
  loading: true,
  applicationsLoading: true,
  error: null,
};

/**
 * Load internship tracks from API
 */
export const loadInternshipTracks = createAsyncThunk('internship/loadTracks', async () => {
  return internshipApi.getAllTracks();
});

/**
 * Load internship applications from API
 */
export const loadInternshipApplications = createAsyncThunk(
  'internship/loadApplications',
  async () => {
    return internshipApi.getAllApplications();
  }
);

/**
 * Save internship track
 */
export const saveInternshipTrack = createAsyncThunk(
  'internship/saveTrack',
  async (track: InternshipTrack, { dispatch }) => {
    const { id, ...trackData } = track;
    const savedTrack = id && isValidObjectId(id) ? await internshipApi.updateTrack(id, trackData) : await internshipApi.createTrack(trackData);
    dispatch(loadInternshipTracks());
    return savedTrack;
  }
);

/**
 * Delete internship track
 */
export const deleteInternshipTrack = createAsyncThunk(
  'internship/deleteTrack',
  async (id: string, { dispatch }) => {
    await internshipApi.deleteTrack(id);
    dispatch(loadInternshipTracks());
    return id;
  }
);

/**
 * Apply for internship
 */
export const applyForInternship = createAsyncThunk(
  'internship/apply',
  async (payload: { application: InternshipApplication; resumeFile?: File }, { dispatch }) => {
    // Strip fields that should be generated by the API
    const { id, date, status, resumeName, resumePath, ...applicationData } = payload.application;
    const savedApplication = await internshipApi.submitApplication(applicationData, payload.resumeFile);
    dispatch(loadInternshipApplications());
    return savedApplication;
  }
);

/**
 * Delete internship application
 */
export const deleteInternshipApplication = createAsyncThunk(
  'internship/deleteApplication',
  async (id: string, { dispatch }) => {
    // Note: API may not have delete endpoint, using update status as fallback
    // If API has delete, uncomment: await internshipApi.deleteApplication(id);
    dispatch(loadInternshipApplications());
    return id;
  }
);

/**
 * Update internship application status
 */
export const updateInternshipApplicationStatus = createAsyncThunk(
  'internship/updateApplicationStatus',
  async ({ id, status }: { id: string; status: InternshipApplication['status'] }, { dispatch }) => {
    await internshipApi.updateApplicationStatus(id, status);
    dispatch(loadInternshipApplications());
    return { id, status };
  }
);

const internshipSlice = createSlice({
  name: 'internship',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // Load tracks
      .addCase(loadInternshipTracks.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(loadInternshipTracks.fulfilled, (state, action) => {
        state.loading = false;
        // Ensure payload is an array and has id fields
        state.tracks = Array.isArray(action.payload) ? action.payload : [];
      })
      .addCase(loadInternshipTracks.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to load internship tracks';
        console.error('Failed to load internship tracks:', action.error);
        // Keep existing tracks on error instead of clearing
        if (state.tracks.length === 0) {
          state.tracks = [];
        }
      })
      // Load applications
      .addCase(loadInternshipApplications.pending, (state) => {
        state.applicationsLoading = true;
        state.error = null;
      })
      .addCase(loadInternshipApplications.fulfilled, (state, action) => {
        state.applicationsLoading = false;
        // Ensure payload is an array and has id fields
        state.applications = Array.isArray(action.payload) ? action.payload : [];
      })
      .addCase(loadInternshipApplications.rejected, (state, action) => {
        state.applicationsLoading = false;
        state.error = action.error.message || 'Failed to load applications';
        // Keep existing applications on error
        if (state.applications.length === 0) {
          state.applications = [];
        }
      })
      // Save/delete track
      .addCase(saveInternshipTrack.fulfilled, (state) => {
        // Tracks are already updated via loadInternshipTracks
      })
      .addCase(saveInternshipTrack.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to save internship track';
      })
      .addCase(deleteInternshipTrack.fulfilled, (state) => {
        // Tracks are already updated via loadInternshipTracks
      })
      .addCase(deleteInternshipTrack.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to delete internship track';
      })
      // Application
      .addCase(applyForInternship.fulfilled, (state) => {
        // Applications are already updated via loadInternshipApplications
      })
      .addCase(applyForInternship.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to submit application';
      })
      .addCase(deleteInternshipApplication.fulfilled, (state) => {
        // Applications are already updated via loadInternshipApplications
      })
      .addCase(deleteInternshipApplication.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to delete application';
      })
      .addCase(updateInternshipApplicationStatus.fulfilled, (state) => {
        // Applications are already updated via loadInternshipApplications
      })
      .addCase(updateInternshipApplicationStatus.rejected, (state, action) => {
        state.error = action.error.message || 'Failed to update application status';
      });
  },
});

export const { clearError } = internshipSlice.actions;

// Selectors
export const selectInternshipTracks = (state: { internship: InternshipState }) =>
  state.internship?.tracks || [];
export const selectInternshipApplications = (state: { internship: InternshipState }) =>
  state.internship?.applications || [];
export const selectInternshipLoading = (state: { internship: InternshipState }) =>
  state.internship.loading;
export const selectApplicationsLoading = (state: { internship: InternshipState }) =>
  state.internship.applicationsLoading;
export const selectInternshipError = (state: { internship: InternshipState }) =>
  state.internship.error;

export default internshipSlice.reducer;

